/* Revised 20191007

To compile use:
g++ -Wall -lpthread -o mowerpigpio mowerpigpio.cpp -lrt -std=c++17

*/

#include <iostream>
#include <ctime>
#include <ratio>
#include <chrono> // For time controls.

using namespace std;
using namespace std::chrono;

// connect to /dev/rfcomm0

// read data

// update screen

// recycle every few seconds for key data (speed, rpm, updates)


// Initialize Control and set to nominal position.
    int kbnumber;
    char kbchar;
    steady_clock::time_point time_boot;
    steady_clock::time_point time_current;
    steady_clock::time_point time_last_locate;
    steady_clock::time_point time_last_picture;
    steady_clock::time_point time_last_mowing;

// Initialize PIGPIO.

// Takes a picture and texts it to the number in the .sh file.
int pic01 (void)
{
	system ("bash ./Picture_with_email.sh");
	return (0);
}

// Takes a picture and saves it.
int pic02 (void)
{
	system ("bash ./Picture.sh");
	return (0);
}

int selftest (void)
{
  return (0);
}

// Reads Sensors and Updates Controls
int controlupdate (void)
{
        mower_on = 1;
        move_on = 1;
	forward_reverse = 1;
        left_detect = gpioRead(16);
        right_detect = gpioRead(20);  
        rear_detect = gpioRead(21);  
        front_detect = gpioRead(12);
	cout << "Front Left Right Rear" << endl;
	cout << front_detect << "     " << left_detect << "    " << right_detect << "     " << rear_detect << endl;
        if(left_detect == 1) {mower_on = 0; direction = (direction + 10);}
        if(right_detect == 1) {mower_on = 0; direction = (direction - 10);}
        if(left_detect == 0 && right_detect == 0) {direction = 0;}
        if(front_detect == 1) {mower_on = 0;forward_reverse = 0;direction = (direction - 10);} 
        if(rear_detect == 1) {mower_on = 0;safety = 1;pic01 ();}
        if(direction > 360) {direction = (direction - 360);}
        if(direction < 0) {direction = (360 + direction);}
        if(mower_on == 1) {gpioWrite (17, 1);}
             else {gpioWrite (17, 0);}
        if(move_on == 1) {gpioWrite (18, 1);}
             else {gpioWrite (18, 0);}
        if(forward_reverse == 1) {gpioWrite (27, 1);}
             else {gpioWrite (27, 0);}
	return 0;
}

// Sets Steering Servo with the variable direction as the input.
// Steering limits of the mechanics need to be expanded. Fixes needed.

int steering (int azimuth)
{
    int c;
    cout << "Steering Module " << azimuth << endl;
    if (azimuth == 360) {c = 1500;}
//  Switch the + and - after 1500 on the next 2 lines if the servo is mounted above the drive.
    if (azimuth >= 0 && azimuth <= 60){c = 1500-azimuth*11;}
    if (azimuth >=300 && azimuth <= 359) {c = 1500 + (360-azimuth)*11;}
    if (azimuth > 60 && azimuth < 300) {c = 1500;direction = 0;}
    return c;
}

int main (void)
{
  time_boot = steady_clock::now();
  time_current = steady_clock::now();
  duration<double> time_span = duration_cast<duration<double>>(time_current - time_boot);
  duration<double> time_picture = duration_cast<duration<double>>(time_current - time_last_picture);
  duration<double> time_mow = duration_cast<duration<double>>(time_current - time_last_mowing);
  duration<double> time_locate = duration_cast<duration<double>>(time_current - time_last_locate);
  selftest ();
  while (time_span.count() < 20)
  {
 
  }
  
// Close Serial Port

return 0 ;
}  

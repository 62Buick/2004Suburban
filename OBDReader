/* Revised 20191007

To compile use:
g++ -Wall -lpthread -o mowerpigpio mowerpigpio.cpp -lrt -std=c++17

*/

// I got this code from : http://www.easysw.com/~mike/serial/serial.html
// Also: http://www.cplusplus.com/doc/tutorial/files/

#include <stdio.h>		//Standard input/output definitions
#include <string.h>		//String function definitions
#include <unistd.h>		//UNIX standard function definitions
#include <fcntl.h>		//File control definitions
#include <errno.h>		//Error number definitions
#include <termios.h>	//POSIX terminal control definitions
#include <iostream>		//Input-Output Streams
#include <ctime>
#include <ratio>
#include <chrono> // For time controls.

using namespace std;
using namespace std::chrono;


// connect to /dev/rfcomm0
//open_port() - Opens serial port and returns file descriptor on success or -1 on error

int open_port(void){
	int fd;		//File descriptor for the port
	struct termios options;

	fd = open("/dev/rfcomm0", O_RDWR | O_NOCTTY | O_NDELAY);

	if (fd == -1){
		//Could not open the port.
		std::cout << "Port Failed to Open";
	}
	else{
		fcntl(fd, F_SETFL, FNDELAY); // Sets the read() function to return NOW and not wait for data to enter buffer if there isn't anything there.

		//Configure port for 8N1 transmission
		tcgetattr(fd, &options);					//Gets the current options for the port
		cfsetispeed(&options, B115200);				//Sets the Input Baud Rate
		cfsetospeed(&options, B115200);				//Sets the Output Baud Rate
		options.c_cflag |= (CLOCAL | CREAD);		//? all these set options for 8N1 serial operations
		options.c_cflag &= ~PARENB;					//? 
		options.c_cflag &= ~CSTOPB;					//?
		options.c_cflag &= ~CSIZE;					//?
		options.c_cflag |= CS8;						//?

		tcsetattr(fd, TCSANOW, &options);			//Set the new options for the port "NOW"

		std::cout << "seems like everything is ok, keep going\n";
	};

	return (fd);
};

int main(void){
	int sPort = -1;
	int written = 0;

	sPort = open_port();

	char *sendThis;

	char something = 'a';

	sendThis = &something;

	if (sPort != -1){
		std::cout << "we're about to write";

		written = write(sPort, sendThis, 1);

		//sPort.write('a', 1);  // A class method can be used to send as well. This write is cleaner and more C++

		if (written < 0 ){
			//Failed to write data to serial port
			std::cout << "Failed to write to port \n";
		};
		
		std::cout << written << " \n" << sendThis;
		//READ stuff here.
	};
	
	close(sPort);

	return 0;
};


// read data

// update screen

// recycle every few seconds for key data (speed, rpm, updates)


// Initialize Control and set to nominal position.
    int kbnumber;
    char kbchar;
    steady_clock::time_point time_boot;
    steady_clock::time_point time_current;
    steady_clock::time_point time_last_locate;
    steady_clock::time_point time_last_picture;
    steady_clock::time_point time_last_mowing;

// Initialize PIGPIO.

// Takes a picture and texts it to the number in the .sh file.
int pic01 (void)
{
	system ("bash ./Picture_with_email.sh");
	return (0);
}

// Takes a picture and saves it.
int pic02 (void)
{
	system ("bash ./Picture.sh");
	return (0);
}

int selftest (void)
{
  return (0);
}

// Reads Sensors and Updates Controls
int controlupdate (void)
{
        mower_on = 1;
        move_on = 1;
	forward_reverse = 1;
        left_detect = gpioRead(16);
        right_detect = gpioRead(20);  
        rear_detect = gpioRead(21);  
        front_detect = gpioRead(12);
	cout << "Front Left Right Rear" << endl;
	cout << front_detect << "     " << left_detect << "    " << right_detect << "     " << rear_detect << endl;
        if(left_detect == 1) {mower_on = 0; direction = (direction + 10);}
        if(right_detect == 1) {mower_on = 0; direction = (direction - 10);}
        if(left_detect == 0 && right_detect == 0) {direction = 0;}
        if(front_detect == 1) {mower_on = 0;forward_reverse = 0;direction = (direction - 10);} 
        if(rear_detect == 1) {mower_on = 0;safety = 1;pic01 ();}
        if(direction > 360) {direction = (direction - 360);}
        if(direction < 0) {direction = (360 + direction);}
        if(mower_on == 1) {gpioWrite (17, 1);}
             else {gpioWrite (17, 0);}
        if(move_on == 1) {gpioWrite (18, 1);}
             else {gpioWrite (18, 0);}
        if(forward_reverse == 1) {gpioWrite (27, 1);}
             else {gpioWrite (27, 0);}
	return 0;
}

// Sets Steering Servo with the variable direction as the input.
// Steering limits of the mechanics need to be expanded. Fixes needed.

int steering (int azimuth)
{
    int c;
    cout << "Steering Module " << azimuth << endl;
    if (azimuth == 360) {c = 1500;}
//  Switch the + and - after 1500 on the next 2 lines if the servo is mounted above the drive.
    if (azimuth >= 0 && azimuth <= 60){c = 1500-azimuth*11;}
    if (azimuth >=300 && azimuth <= 359) {c = 1500 + (360-azimuth)*11;}
    if (azimuth > 60 && azimuth < 300) {c = 1500;direction = 0;}
    return c;
}

int main (void)
{
  time_boot = steady_clock::now();
  time_current = steady_clock::now();
  duration<double> time_span = duration_cast<duration<double>>(time_current - time_boot);
  duration<double> time_picture = duration_cast<duration<double>>(time_current - time_last_picture);
  duration<double> time_mow = duration_cast<duration<double>>(time_current - time_last_mowing);
  duration<double> time_locate = duration_cast<duration<double>>(time_current - time_last_locate);
  selftest ();
  while (time_span.count() < 20)
  {
 
  }
  
// Close Serial Port

return 0 ;
}  
